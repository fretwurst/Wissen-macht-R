{
  "hash": "b573852da8c9d861a889a0087e6de516",
  "result": {
    "markdown": "# Datenaufbereitung\n\nLaden Sie sich als erstes die Datei <a href=\"templates/Auswertung.Rmd\" download>Auswertung.Rmd</a> herunter. Darin finden Sie Codebeispiele, die Sie kopieren können und so ändern, dass Sie auf Ihre Datensätze und zu Ihren Variablen passen. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n vembedr::embed_youtube(\"huBJnXr70SE\") |> \n  vembedr::use_rounded()\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"vembedr\">\n<div class=\"vembedr-rounded\">\n<iframe src=\"https://www.youtube.com/embed/huBJnXr70SE\" width=\"533\" height=\"300\" frameborder=\"0\" allowfullscreen=\"\" data-external=\"1\"></iframe>\n</div>\n</div>\n```\n:::\n:::\n\n\n## Leere Fälle löschen (TF E)\n\nHier gehe ich davon aus, dass ein Interview erfolgreich beendet wurde, wenn der:die Interviewer:in am Ende etwas zum Verständnis des Interviews eingegeben hat. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDATEN_BF <- DATEN_BF |> \n  filter(!is.na(PLZ))\n\n## Das geht nur einmal, weil R dann die Variablen nicht mehr findet, die wir gerade gelöscht haben, logisch\nDATEN_BF <- DATEN_BF |> \n  select(-c(SERIAL:MODE)) \n\nDATEN_BF <- DATEN_BF |> \n  relocate(INTERVIEWER, .after = STARTED)\n```\n:::\n\n\n## Variablen umbenennen und löschen\n\nWenn Sie den einfachen Befehl \"select\" nehmen, dann werden die Variablen behalten, die Sie aufführen. Wenn Sie ein Minus davor schreiben, werden die Variablen gelöscht, die Sie aufführen. Häufig führt das später zu Fehlermeldungen, weil bei mehrfacher Ausführung gelöschte Variablen natürlich nicht mehr im Datensatz gefunden werden. Um diesen Fehlermeldungen aus dem Weg zu gehen, können Sie \"any_of\" verwenden. Dann prüft R, ob eine der aufgeführten Variablen im Datensatz sind und löscht diese. Wenn die Variablen nicht im Datensatz sind, dann macht R nichts weiter (meldet auch keinen Fehler und stoppt Ihren Durchlauf nicht.). Seien Sie damit also mir Vorsicht. Beim Befehl \"rename\" können Sie das auch machen. Mit \"any_of\" werden nur die Variablen umbenannt, die auch wirklich da sind. Manchmal kommt das bei jedem Durchlauf vor, weil zB bei join-Befehlen immer nochmal ein Datensatz gematcht wird und wie im Beispiel vorhandene Variablen wie \"Nenn1\" umbenannt werden in \"Nenn1.x\" und Nenn1.y\" Wenn Sie jetzt die mit \".y\" löschen und die mit \".x\" umbenennen, dann haben Sie das Problem auch glöst, wenn Ihnen nicht ganz klar ist, warum die immerwieder auftauchen. Für's Erste ist das also auch eine Lösung eines Problems. ;-)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Manchmal macht es Sinn, von einer Variable eine Kopie mit besser lesbarem Namen anzulegen, wie hier:\n\nDATEN_BF <- DATEN_BF |> \n  mutate(Alter = SD01,\n         Geschlecht = SD02)\n\n# So können Sie Variablen löschen. Durch das -any_of gibt es keine Fehler, wenn R die Variablen nicht findet\nDATEN_BF <- DATEN_BF |> \n  select(-any_of(c(\"Nenn1.y\", \"Nenn2.y\", \"Nann3.y\")))\n# So nenne Sie Variablen um (vorne wie es bisher hiess).\n\nDATEN_BF <- DATEN_BF |> \n  rename(any_of(c(\"Nenn1.x\" = \"Nenn1\", \"Nenn2.x\" = \"Nenn2\", \"Nenn3.x\" = \"Nenn3\"))) \n```\n:::\n\n\n\n## Label für Variablen und Ausprägungen (teils TF E)\n\nWenn Sie messen, dann stehen am Ende Zahlen für das was Sie gemessen, also zB erfragt haben. Zum Beispiel steht dann eine 1 für \"trifft nicht zu\" und 5 für \"trifft vollkommen zu\". In Ihren Auswertungen müssen Sie aber wieder die verbalen Entsprechungen nutze, statt nur Tabellen oder Grafiken zu haben, wo nur Zahlen ausgewiesen werden (Sie können das noch verbinden, aber Ihre Leser:innen nicht). In anderen Programmen (wie SPSS) ist es daher üblich, dass die gemessenen Zahlen mit verbalen Labeln versehen werden. In Base-R geht das nicht so toll. Da müssen Sie mit \"factors\" arbeiten, wo also statt der Zahlen die verbalen Entsprechungen verwendet werden. Mühsam an den Faktoren ist, dass man mit ihnen wieder nicht mehr rechnen kann, also z.B. weder einen Mittelwert ausgeben noch eine Korrelation. Da hilft das Paket sjmisc weiter. Mit dem können Sie den Zahlenwerten Ihrer Variablen ihre Merkmalsausprägungen als Label zuordnen. Das geht mit set_label(labels = c(\"tzrifft nicht zu\" = 1, \"trifft voll zu\" = 5)):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# So können Label vergeben werden\n\nDATEN_BF |> sjmisc::frq(GESCHL)\n\n# Hier wird das Variablenlabel vergeben\n\nDATEN_BF <- DATEN_BF |> \n  sjlabelled::var_labels(GESCHL = \"Geschlecht\") \n\n# Hier werden für die einzelnen Ausprägungen die Label vergeben\nDATEN_BF <- DATEN_BF |> \n  sjlabelled::set_labels(GESCHL, labels = c(\"mänlich\" = 1, \"weiblich\" = 2, \"divers\" = 3, \"k.A.\" = NA))\n\n# Mit dem Befehl für Häufigkeitstabellen (frq für frequencies) kann die Labelei schnell angesehen werden:\n\nDATEN_BF |> \n  sjmisc::frq(GESCHL)\n\n## Hier werden für einige Variablen Label vergeben, die zusammengehören und später als Auswertung für Mehrfrachantworten verarbeitet werden\n\n# Ersteinmal die Variablen angucken. Die Variablen gehen von NACHRICHT_TITEL1 in einer Reihe bis M112_23 (wurde nicht umbenannt in SosciSurvey)\nDATEN_BF |> \n  select(NACHRICHT_TITEL1:M112_23) |> # Nur die interessierenden Variablen selektieren\n  multiResponse() |> # Mehrfachantworten ansehen\n  arrange(desc(Frequency)) |> # Sortieren nach Häufigkeit\n  kableExtra::kable() |> # besser lesbare Tabelle daraus machen\n  kableExtra::kable_styling() # Styling\n\n\n# Mit set_variable_labels werden hier die Variablenlabel vergeben\nDATEN_BF <- DATEN_BF |>\n  sjlabelled::var_labels(NACHRICHT_TITEL1 = \"NZZ\", \n                      NACHRICHT_TITEL2 = \"TA\", \n                      NACHRICHT_TITEL3 = \"20 Minuten\",\n                      NACHRICHT_TITEL4 = \"Blick\", \n                      NACHRICHT_TITEL5 = \"Watson\",\n                      NACHRICHT_TITEL6 = \"SRF News\", \n                      M112_20 = \"Social Media\",\n                      M112_21 = \"Google News\",\n                      M112_23 = \"anderes\"\n                      )\n\n# Hier mal für den Nachrichtenfaktor \"Kontroverse\" aus der Inhaltsanalyse\n\nDATEN_IA <- DATEN_IA |> \n sjlabelled::var_labels(KNTR, label = \"Kontroverse\") |> \n sjlabelled::set_labels(KNTR, labels = c(\"keine\" = 0, \"gering\" = 1, \"stark\" = 2, \"k.A.\" = NA))\n```\n:::\n\n\n## Befragungstag aus dem Datum\n\nMit diesem Befehl kann der Befragungstag aus der Datumsvariable erzeugt werden, die von SosciSurvey automatisch erzeugt wird.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDATEN_BF <- DATEN_BF |> \n  mutate(Befrag_Tag = day(STARTED)) |> # mit day wird aus der Datumsvariable der Tag rausgezogen\n  relocate(Befrag_Tag, .after = STARTED) # Hiermit wird die Variable für den Befragungsstart an den Anfang gepackt\n\nDATEN_BF |> sjmisc::frq(Befrag_Tag)\n```\n:::\n\n\n## Umkodieren\n\n### Werte wechseln\n\nUmkodieren bedeutet, dass Ausprägungen (also Werte) in einer Variablen verändert werden oder zu anderen Werten in einer neuen Variable werden. Typische Umkodierungen sind Veränderungen der Codes (also zB wenn man eine Skala umdrehen möchte von 1 bis 5 auf 5 bis 1) und Zusammenfassungen von Codes, also zB 1 und 2 werden neu in 1 zusammengefasst 3 wird die neue 2 und 4 sowie 5 werden als neue 3 kodiert. Dann hat man jeweils zwei Abstufungen in den Ausprägungen zu jeweils einer zusammengefasst. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Hier machen wir aus den beiden tieferen Bildungsgruppen eine einzelne Gruppe. In den Klammern kann man die Value Label gleich mit vergeben:\n\nDATEN_BF |> sjmisc::frq(BILDUNG) # erstmal angucken\n\n# Erstelle mit mutate eine neue Variable BILDUNG_gr, die eine Rekodierung (rec) der Variable BILDUNG (zB 1 und 2 werden 1 mit dem Label \"tief\")\nDATEN_BF <- DATEN_BF |> \n mutate(BILDUNG_gr = rec(BILDUNG, rec = \"1:2 = 1; 3 = 2; 4 = 3; 5 = 4\"))  # die offenen müssen noch kodiert werden\n\nDATEN_BF <- DATEN_BF |> \n  sjlabelled::set_labels(BILDUNG_gr, labels = c(\"tief\" = 1, \"mittel\" = 2, \"hoch\" = 3, \"noch kodieren\" = 4), force.labels = TRUE) |> \n  sjlabelled::var_labels(BILDUNG_gr, label = \"Bildung (gruppiert)\")  # hier das Variablenlabel\n\nDATEN_BF |> \n    sjmisc::frq(BILDUNG_gr)\n```\n:::\n\n\n### Mehrere auf einmal umkodieren \n\n\n::: {.cell}\n\n```{.r .cell-code}\nDATEN_BF |> \n  frq(HAUFIGKEIT_01:HAUFIGKEIT_05)\n\n# mutiere across die ganze Liste der Variablen von:bis, als Funktion (~) rec(.x) wobei .x für die Liste steht\nDATEN_BF <- DATEN_BF |> \n  mutate(across(HAUFIGKEIT_01:HAUFIGKEIT_05, \n                ~ rec(.x, rec = \"1 = -2 [viel zu wenig]; 2 = -1 [zu wenig]; 3 = 0 [richtig]; 4 = 1  [zu viel]; 5 = 2 [viel zu viel]; else = NA\"), \n                       .names = \"{.col}_um0\")) |> # HIer werden an die Variablennamen Suffixe \"_um0\" angehängt\n  sjlabelled::var_labels(HAUFIGKEIT_01_um0 = \"Corona\", # Hier noch Label für die Variablen\n             HAUFIGKEIT_02_um0 = \"Abstimmungen\", \n             HAUFIGKEIT_03_um0 = \"Finanz\", \n             HAUFIGKEIT_04_um0 = \"Klima\", \n             HAUFIGKEIT_05_um0 = \"Geflüchtete\")\n\nDATEN_BF |> \n  sjmisc::frq(HAUFIGKEIT_01_um0:HAUFIGKEIT_05_um0)\n```\n:::\n\n\n### NA durch 0 ersetzen\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDATEN_IA |> \n  mutate(across(Nenn1:Nenn5), ifelse(is.na(.x) == TRUE, 0, .x)))\n```\n:::\n\n\n\n### Ausprägungen zusammenfassen \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Das Alter in Gruppen zusammenfassen\nDATEN_BF <- DATEN_BF |> \n  mutate(ALTER_gr = case_when(\n    ALTER < 0 ~ NA_real_,\n    ALTER <= 25 ~ 1,\n    ALTER <= 45 ~ 2,\n    ALTER <= 65 ~ 3,\n    ALTER <= 85 ~ 4,\n    ALTER > 85 ~ 5\n  ))  |> \n  sjlabelled::set_labels(ALTER_gr, labels = c(\"bis 25\"  = 1, \"26-45\" = 2, \"46-65\" = 3, \"66-85\" = 4, \"85+\" = 5)) |> \n  sjlabelled::var_labels(ALTER_gr = \"Alter gruppiert\")\n\nDATEN_BF |> frq(ALTER_gr)\n\n# Hier werden für die Inhaltsanalyse die Anzahl Worte in Gruppen zusammengefasst.\nDATEN_IA <- DATEN_IA |> \n  mutate(WORTE_gr = rec(WORT_AZ, \n                        rec = \"0:100 = 1 [Kurzmeldung];\n                        101:150 = 2 [kurzer Artikel]; \n                        151:300 = 3 [länger]; \n                        301:500 = 4 [lang]; \n                        501:max = 5 [Langtext]\")) |> \n    relocate(WORTE_gr, .after = WORT_AZ) \n\n\n### Rekodierung der Anzahl Nennungen in wenige Gruppen\nDATEN_IA <- DATEN_IA |> \n  mutate(Nenn_Gr = rec(Nenn_Gesamt, rec = \"1:3 = 1; 4:16 = 2; 17:100 = 3\")) |> \n  sjlabelled::set_labels(Nenn_Gr, labels = (c(\"selten\" = 1, \"mittel\" = 2, \"häufig\" = 3)))\n```\n:::\n\n\nMedium umkodieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1\tSRF\n# 2\t20min\n# 3\tWatson\n# 4\tNZZ\n# 5\tTagesanzeiger\n# 6\tBlick\n\nDATEN_IA <- DATEN_IA |> \n  mutate(Medium_Q = rec(MEDIUM, \n                    rec = \"1,4,5 = 1 [Qualität]; 2,3,6 = 2 [Boulevard]\")) \n\nDATEN_IA |> sjmisc::frq(Medium_Q)\n```\n:::\n\n\n### Bedingt umkodieren\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDATEN_BF |> \n  sjmisc::frq(ALTER, BILDUNG_gr)\n\nDATEN_BF <- DATEN_BF |> \n  mutate(Alt_Bild1 = if_else(ALTER < 35 & BILDUNG_gr == 3, 1, 2)) \n\nDATEN_BF |>  frq(Alt_Bild1)\n\n# Hier erstmal umkodieren uns anschauen\n\nDATEN_BF |> \n  mutate(Alt_Bild2 = case_when(\n    ALTER < 35 & BILDUNG_gr == 3 ~ 1, \n    ALTER > 75 & BILDUNG_gr == 3 ~ 2,\n  )) |> \n  var_labels(Alt_Bild2 = \"Alter und Bildung\") |> \n  set_labels(Alt_Bild2, labels = c(\"Junggebildet\" = 1, \"Altgebildet\" = 2)) |> \n  frq(Alt_Bild2) # erstmal nur eine Frequencies als Ergebnis und nicht gleich den Daten hinzufügen\n\n# Dann dem Datensatz hinzufügen\nDATEN_BF <- DATEN_BF |> \n  mutate(Alt_Bild2 = case_when(\n    ALTER < 35 & BILDUNG_gr == 3 ~ 1, \n    ALTER > 75 & BILDUNG_gr == 3 ~ 2,\n  )) |> \n  sjlabelled::var_labels(Alt_Bild2 = \"Alter und Bildung\") |> \n  sjlabelled::set_labels(Alt_Bild2, labels = c(\"Junggebildet\" = 1, \"Altgebildet\" = 2))\n```\n:::\n\n\n### Variablen zu Indizes zusammenfassen\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ein Summenindex für 10 Variablen zur Nachrichtennutzung Es wird zeilenweise die Summe für die Dummys (0/1-Variablen) berechnet\n\nDATEN_BF <- DATEN_BF |> \n  mutate(MEDIEN_sum = rowSums(across(NACHRICHT_TITEL1:NACHRICHT_TITEL10), na.rm = TRUE))\n\nDATEN_BF |> \n  sjmisc::frq(MEDIEN_sum)\n\n# Hier noch der Durchschnittswert als Index, was bei Dummys der Anteil der 1-er ist, also wenn 68 von knapp 200 Leuten 2 Medien nannten, dann gibt es 68 mal die 0.2 \n\nDATEN_BF <- DATEN_BF |> \n  mutate(MEDIEN_mean = rowMeans(across(NACHRICHT_TITEL1:NACHRICHT_TITEL10), na.rm = TRUE))\n\nDATEN_BF |> \n  sjmisc::frq(MEDIEN_mean)\n\nmutate\n\nDATEN_IA <- DATEN_IA |> \n  mutate(across(c(PERS:KNTR, KAT:NAEHE), ~replace(.x, is.na(.x),0))) |> \n  mutate(across(c(PERS:KNTR, KAT:NAEHE), ~replace(.x, .x == -9,0))) |> \n  rowwise() |> \n  mutate(Jour_Beacht = sum(c(PERS:KNTR, KAT:NAEHE)))\n\nDATEN_IA |> sjmisc::frq(Jour_Beacht)\n```\n:::\n\n\n\n### Umfangreiche Umkodierungstabellen (TF E)\n\nZum Beispiel für Ländereigenschaften über die Ländercodes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvembedr::embed_youtube(\"5BR3m7E6E-s\") |> \n  vembedr::use_rounded()\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"vembedr\">\n<div class=\"vembedr-rounded\">\n<iframe src=\"https://www.youtube.com/embed/5BR3m7E6E-s\" width=\"533\" height=\"300\" frameborder=\"0\" allowfullscreen=\"\" data-external=\"1\"></iframe>\n</div>\n</div>\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Aus der Länderliste mit den Kodierungen kommen die Variablen für eine Laenderliste:\nLaenderliste <- readxl::read_xlsx(\"Daten/Laender_Liste_Kodierung.xlsx\", sheet = \"Länderliste\")\n\n# Die Codes für die Länder kommen aus einer anderen Untertabelle der Excel, darum steht hinten bei sheets etwas anderes:\nLändercodes <- readxl::read_xlsx(\"Daten/Laender_Liste_Kodierung.xlsx\", sheet = \"Ländercodes\")\n\n# Dann gibt es noch lauter weitere Codes, die wir jetzt anmatchen können, die können wir später gut gebrauchen, weil verschiedene Datensätze aus dem Internetz verschiedene Ländercodes verwenden\n\nLand_AlphaISO <- readxl::read_xlsx(\"Daten/Laender_Liste_Kodierung.xlsx\", sheet = \"AlphaISO\") |> \n  select(name, \"alpha2\", \"alpha3\", \"CountryCode\")\n\n# Hier binden wir die zusammen, erst die Ländercodes an die Laenderliste und dann noch die Land_AlphaISO hinten dran\nLaender <- left_join(Laenderliste, Ländercodes, by = \"Land\") |> \n  left_join(., Land_AlphaISO, by = \"alpha2\")\n\n# oh, und hier noch ein paar Handelsdaten, falls das jemanden interessiert\nWorldTrade <- economiccomplexity::world_gdp_avg_1998_to_2000\n\n# So, die kleben wir jetzt auch noch hinten an unsere Laendervariable\nLaender <- left_join(Laender, WorldTrade, by = c(\"alpha3\" = \"country\"))\n\n# mit diesem Paket können Sie die Coronazahlen aller Länder als Datensatz laden, für jeden Tag\nCovid_JHU <- tidycovid19::download_jhu_csse_covid19_data() # das dauert bischen\nCovid_WBank <- tidycovid19::download_wbank_data()\n\n# jetzt nehme ich den Covid-Datensatz und ...\nCovid_Land <- Covid_JHU |> \n  filter(date >= \"2020-12-4\" & date <= \"2020-12-6\") |> # filtere so, dass nur die Daten der Feldphase bleiben (auf die Tage der Feldphase achten)\n  group_by(iso3c) |> # hier gruppiere ich nach den Ländern, die im Code iso3c (dreistellig character) stehn\n  summarise(C19_Gesamt = max(confirmed), # hier summiert R die maximal bestätigten (also kummulierten) Fallzahlen\n            C19_Feldwoche_krank = sum(confirmed - recovered)) # hier noch die Summe der Kranken in der Feldphase\n\n# Hier kleben wir wieder die Covid-Daten an die Laender dran\nLaender <- left_join(Laender, Covid_Land, by = c(\"alpha3\" = \"iso3c\")) \n\n# Schreibe die Laender-Daten raus in die Exceldatei \"Laender_codes.xlsx\"\nwritexl::write_xlsx(Laender, \"Daten/Laender_codes.xlsx\")\n\n# Hier die Laender-Daten wieder aus der (eventuell ergänzten Laender-Excel) in R laden:\nLaender <- readxl::read_xlsx(\"Daten/Laender_codes.xlsx\")\n\n# Jetzt kommt die Magie. Wie matchen die Laendervariable an die Inhaltsanalysedaten:\n\n# Hier lade ich die Inhaltanalysedaten aus meiner Excel. Vermutlich heisst die Excel bei Ihnen anders und liegt vielleicht auch nicht im Unterordner \"Daten\".\nIA <- readxl::read.xlsx(\"Daten/IA_Gesamt.xlsx\")\n\n# Hier werden alle Variablen aus der Laendertabelle hinten an die Inhaltsanalyse geklebt\nIA <- left_join(IA, Laender, by = c(\"LAND\" = \"Code\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"site_libs/vembedr-0.1.5/css/vembedr.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}